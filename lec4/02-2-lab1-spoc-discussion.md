# lab1 SPOC思考题


## 各知识点的小练习

### 4.1 启动顺序
---
读入ucore内核的代码？

- [x]  

> 

跳转到ucore内核的代码？

- [x]  

> 

段寄存器的字段含义和功能有哪些？
- [x]  

> 

什么是全局描述符表GDT和局部描述符表LDT？
- [x]  

> 

全局描述符表的初始化代码？

- [x]  

> 

GDT内容的设置格式？初始映射的基址和长度？特权级的设置位置？

- [x]  

>

描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中这些字段？对应的访问条件是什么？ (challenge)写出一些简单的小程序（c or asm）来体现这些特权级的区别和联系。
 ```
  + 建议参见链接“ http://blog.csdn.net/better0332/article/details/3416749 ”对特权级的表述，并查阅指令手册。
  - 
 ```

  - CPL：当前进程的权限级别，代码段寄存器CS中的CPL字段（2位）的值等于CPU当前的特权级。
  
  - RPL：数据段选择子中的内容可以加载到各个段寄存器（如SS、DS），低两位为请求特权级（RPL），表示进程对段的访问权限。
  
  - DPL：描述符特权，储存在段描述符中的权限位，用于描述对应段所属的特权等级，每个段的DPL固定。

  - 访问条件：max(RPL,CPL)<=DPL
  
  - 输出CPL程序：
  
  ```c
  int cs = 0;
  asm volatile("movl %%cs, %0\n" : "=r"(cs));
  cs &= 3;
  cprintf("user mode CPL: %d\n", cs);
  ```
  在syscall.c中，同样输出CPL。
  结果如下：
  
  ![](challenge1.png "challenge1 code")


> 

CR0控制寄存器的字段含义和功能有哪些？
- [x]  

> 

可执行文件格式elf的各个段的数据结构？

- [x]  

> 

如果ucore内核的elf是否要求连续存放？为什么？

- [x]  

> 
---

### 4.2 C函数调用的实现
---

函数调用的stackframe结构？函数调用的参数传递方法有哪几种？
- [x]  

> 

系统调用的stackframe结构？系统调用的参数传递方法有哪几种？

- [x]  

> 

分析ucore的系统调用实现代码；
- [x]  

> 

分析Linux的系统调用实现代码；
- [x]  

> 

比较不同特权级的中断切换时的堆栈变化差别；(challenge)写出一些简单的小程序（c or asm）来显示出不同特权级的的中断切换的堆栈变化情况。

 - uCore中CPU只用到2个特权级：0（内核态）和3（用户态）。
 - 当处于内核态时，中断切换时堆栈不需要切换，即一直是内核态堆栈；
 - 当处于用户态时，中断时堆栈从用户态堆栈切换到内核态堆栈，中断处理结束后堆栈再回到用户态堆栈。

> 

---

### 4.3 GCC内联汇编
---

使用内联汇编的原因？

- [x]  

> 特权指令、性能优化

对ucore中的一段内联汇编进行完整的解释？

- [x]  

> 
---

### 4.4 x86中断处理过程
---

4.4 x86中断处理过程

中断描述符表IDT的结构？

- [x]  

> 

中断描述表到中断服务例程的地址计算过程？

- [x]  

> 

中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

- [x]  

> 

中断处理中硬件保存了哪些寄存器？

- [x]  

>

trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

- [x]  

>

---

### 4.5 练习一 ucore编译过程
---

gcc编译、ld链接和dd生成两个映像对应的makefile脚本行？

- [x]  
> 

在函数print_stackframe中要调用函数print_debuginfo(uintptr_t eip)来打印函数源码位置信息，
```
  print_stackframe(void)
   eip = read_eip();
   #option 1
   print_debuginfo(eip - 1);
   #option 2
   print_debuginfo(eip );
```
请问option1和 option2 的结有何区别？请说明。

- [x]  

对于如下5条语句执行后得到的5个eip（类型为uint32_t）的结果的数值关系是什么？
```
  eip = ((uint32_t *)ebp)[2];
  eip = ((uint32_t *)ebp)[1];
  eip = ((uint32_t *)(ebp+4);
  eip = ((uint32_t *)(ebp+2);
  eip = ((uint32_t *)(ebp+1);
```        

- [x]  

> 

---

### 4.6 练习二 qemu和gdb的使用
---

qemu的命令行参数含义解释？

- [x]  

> 

gdb命令格式？反汇编、运行、断点设置

- [x]  

> 
---

### 练习三 加载程序
---

A20的使能代码分析？

- [x]  

> 

生成主引导扇区的过程分析？

- [x]  

> 

保护模式的切换代码？

- [x]  

> 

如何识别elf格式？对应代码分析？

- [x]  

> 

跳转到elf的代码？

- [x]  

> 

函数调用栈获取？

- [x]  

> 

---

### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析
---

如何识别elf格式？对应代码分析？

- [x]  

> 

跳转到elf的代码？

- [x]  

> 

函数调用栈获取？
- [x]  

> 

函数read_ebp是inline的，而函数read_eip是__noinline的，能否正好相反设置，即设置函数read_ebp是_noinline的，而函数read_eip是inline的？为什么？
- [x]

>

---


### 4.9 练习六 完善中断初始化和处理
---

各种设备的中断初始化？
- [x]  

> 

中断描述符表IDT的排列顺序？
- [x]  

> 中断号

CPU加电初始化后中断是使能的吗？为什么？

- [x]  

> 

中断服务例程的入口地址在什么地方设置的？

- [x]  

> 

alltrap的中断号是在哪写入到trapframe结构中的？

- [x]  

> 

trapframe结构？
- [x]  

> 

---

## v9-cpu相关题目
---

### 提前准备
```
cd YOUR v9-cpu DIR
git pull 
cd YOUR os_course_spoc_exercise DIR
git pull 
```

### v9-cpu的执行过程(challenge)
  1. 参考os*.c，写一个小程序，能够显示在用户态无法执行的所有特权指令，能够显示出不同特权级的的中断切换的堆栈变化情况。
  1. 扩展em.c，可以打印v9-cpu执行的每一条指令和寄存器状态
  1. 扩展em.c，在产生fatal错误后，把这之前执行的n条指令和寄存器状态打印出来
  1. 扩展c.c和em.c，使得可以指定em.c能够跟踪并打印执行程序中对全局变量的读写或修改的指令，以及指令的执行情况
  1. 扩展em.c的debugger功能，可以设置断点
  1. 扩展em.c的debugger功能，可以任意打断当前执行程序的执行，回到debugger
